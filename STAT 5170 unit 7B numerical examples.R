# =================================================================================
# STAT 5170: Applied Time Series
# Numerical examples for part B of learning unit 7
# =================================================================================
#
# =================================================================================
# Example time series
# =================================================================================
#
# ---------------------------------------------------------------------------------
# Dow Jones Industrial Average daily returns time series
# ---------------------------------------------------------------------------------

# Daily values of the Dow Jones Industrial Average (DJIA) may be collected using functionality provided in the "quantmod" package.

#install.packages("quantmod")
library(quantmod)

# Values from April 20, 2006 to April 20, 2016 are obtained by the following code

getSymbols("^DJI", from="2006-04-20", to="2016-04-20")
djia <- DJI$DJI.Close

# They are converted to approximate returns defined as the first-order difference of log-transformed values.

djiar <- diff(log(djia))[-1]

plot(djiar, type="n", main="DJIA approximate returns")
lines(djiar, lty=1, lwd=1)

# The period around the financial crisis of 2008 is one of high volatility.

# ---------------------------------------------------------------------------------
# Simulated ARCH and GARCH time series
# ---------------------------------------------------------------------------------

# The two functions defined below simulate a sample path of either a ARCH or GARCH time series.

arch.sim <- function(n, alpha, r0=NA) {
	n.alpha <- length(alpha)
	m <- n.alpha - 1
	eps.samp <- rnorm(n=n, mean=0, sd=1)
	if (is.na(r0)) {
		pastr2 <- rep(x=0, times=m)
	} else {
		pastr2 <- c(r0^2, rep(x=0, times=m-length(r0)))
	}
	arch.samp <- numeric(length=n)
	sig.samp <- numeric(length=n)
	for (t in 1:n) {
		sig2 <- alpha[1] + sum(alpha[2:n.alpha]*pastr2)
		sig.samp[t] <- sqrt(sig2)
		arch.samp[t] <- sig.samp[t]*eps.samp[t]
		pastr2 <- c(arch.samp[t]^2, pastr2[1:m-1])
	}
	arch.ts <- ts(arch.samp)
	result <- list(ts=arch.ts, sig=sig.samp)
	return(result)
}

garch.sim <- function(n, alpha, beta, sigw, r0=NA, v0=NA) {
	n.alpha <- length(alpha)
	p <- n.alpha - 1
	q <- length(beta)
	eps.samp <- rnorm(n=n, mean=0, sd=1)
	if (is.na(r0)) {
		pastr2 <- rep(x=0, times=p)
	} else {
		pastr2 <- c(r0^2, rep(x=0, times=m-length(r0)))
	}
	if (is.na(v0)) {
		pastv <- rep(x=0, times=q)
	} else {
		pastv <- c(v0, rep(x=0, times=q-length(v0)))
	}
	garch.samp <- numeric(length=n)
	sig.samp <- numeric(length=n)
	for (t in 1:n) {
		sig2 <- alpha[1] + sum(alpha[2:n.alpha]*pastr2) + sum(beta*pastv)
		sig.samp[t] <- sqrt(sig2)
		garch.samp[t] <- sig.samp[t]*eps.samp[t]
		pastr2 <- c(garch.samp[t]^2, pastr2[1:p-1])
		pastv <- c(sig2, pastv[1:q-1])
	}
	garch.ts <- ts(garch.samp)
	result <- list(ts=garch.ts, sig=sig.samp)
	return(result)
}

# A simulated ARCH time series is generated by the code below. The code also creates a plot of its simulated sample path in the same figure with a plot of the time series of conditional standard deviations, all of which in included in the output to the arch.sim function.

n <- 1000
alpha <- c(0.25, 0.45)
arch.data <- arch.sim(n=n, alpha=alpha)

par(mfrow = c(2, 1))
par(mar=c(2.00, 2.00, 1.00, 1.00)) #bottom, left, top, and right
ts.plot(arch.data$ts, xlab="", ylab="value", main=paste("ARCH(", length(alpha)-1, ")", sep=""))
ts.plot(arch.data$sig, lty=2, col="blue", xlab="", ylab="value", main="std dev")
par(mfrow = c(1, 1))

# The following code repeats the simulation and plot creation for a GARCH time series.

n <- 1000
alpha <- c(0.25, 0.45)
beta <- c(0.1)
garch.data <- garch.sim(n=n, alpha=alpha, beta= beta)

par(mfrow = c(2, 1))
par(mar=c(2.00, 2.00, 1.00, 1.00)) #bottom, left, top, and right
ts.plot(garch.data$ts, xlab="", ylab="value", main=paste("GARCH(", length(alpha)-1, ",", length(beta), ")", sep=""))
ts.plot(garch.data$sig, lty=2, col="blue", xlab="", ylab="value", main="std dev")
par(mfrow = c(1, 1))

# Patterns exhibited in the sample ACF and PACF of the time series reflect that each is uncorrelated.

par(mfrow = c(2, 2))
par(mar=c(2.00, 2.00, 1.0, 1.00)) #bottom, left, top, and right
acf(arch.data$ts, ylim=c(-1,1))
text(x=25, y=1.0, labels="ARCH", pos=1)
text(x=25, y=0.8, labels="ACF", pos=1)
pacf(arch.data$ts, ylim=c(-1,1))
text(x=25, y=1.0, labels="ARCH", pos=1)
text(x=25, y=0.8, labels="PACF", pos=1)
acf(garch.data$ts, ylim=c(-1,1))
text(x=25, y=1.0, labels="GARCH", pos=1)
text(x=25, y=0.8, labels="ACF", pos=1)
pacf(garch.data$ts, ylim=c(-1,1))
text(x=25, y=1.0, labels="GARCH", pos=1)
text(x=25, y=0.8, labels="PACF", pos=1)
par(mfrow = c(1, 1))

# =================================================================================
# Volatility and kurtosis
# =================================================================================
#
# We have formulas for the expected squared-returns and kurtosis of an ARCH(1) time series. The following code evaluates these quantities for a given set of parameters

alpha <- c(0.25, 0.45)

Er2.form <- alpha[1] / (1 - alpha[2])
Er2.form

Er4.form <- 3*alpha[1]^2*(1+alpha[2]) / ((1 - alpha[2])*(1-3*alpha[2]^2))
Er4.form

kappa.form <- Er4.form / (Er2.form)^2
kappa.form

# The following code spot-checks these computed values, by calculating the corresponding sample values on a long simulated ARCH(1) time series with the same parameters.

n <- 100000
arch.data <- arch.sim(n=n, alpha=alpha)

Er2.sim <- mean(arch.data$ts^2)
Er4.sim <- mean(arch.data$ts^4)
kappa.sim <- Er4.sim / (Er2.sim)^2

# The calculations are compared as follows.

print(paste("   E[r2]: simulated=", sprintf("%6.4f", Er2.sim), ", formula=", sprintf("%6.4f", Er2.form), sep=""))
print(paste("   E[r4]: simulated=", sprintf("%6.4f", Er4.sim), ", formula=", sprintf("%6.4f", Er4.form), sep=""))
print(paste("kurtosis: simulated=", sprintf("%6.4f", kappa.sim), ", formula=", sprintf("%6.4f", kappa.form), sep=""))

# Discrepancies between the values given by the formulas and those found by simuation are due to sampling error, but it is sampling error that is inherent to an ARCH model becasue of its tendancy to go through periods of high volutility, which creates outliers, and partly because the kurtosis is sensitive to outliers, which magnifies the problem. Notice, for example, that the calculations largely agree for expected squared returns, at least to a much greater degree than they do for the expected fourth power of returns and kurtosis.

# =================================================================================
# Parameter estimation using ARCH and GARCH models
# =================================================================================
#
# The "fGarch" package includes functionality for analyzing time series under and ARCH or GARCH model.

#install.packages("fGarch")
library("fGarch")

# ---------------------------------------------------------------------------------
# Dow Jones Industrial Average daily returns time series
# ---------------------------------------------------------------------------------

# The code below uses the "garchFit" function to estimate parameters of the DJIA approximate returns time series. 

# The model specified by the input arguments is an AR(1) model for the returns with a GARCH(1,1) model for the errors. The specified distribution of the errors is also non-standard: a Student t distribution (std) is specified in place of the default standard normal distributions.

# Executing the function produces extensive printed output. Details of the analysis may be stored by assignging the function output to a variable.

djia.tsa <- garchFit(~arma(1,0)+garch(1,1), data=djiar, cond.dist='std')

# A digestable summary of the analysis is produced by applying the summary function to the "garchFit" function output.

summary(djia.tsa)

# The following parameter estimates are observed

# Parameter estimates:
# mu:      0.0008561
# ar1:    -0.05538
# omega:   0.000001615 (= alpha0)
# alpha1:  0.1244
# beta1:   0.8700
# df:      5.989

# A variety of plots may be explored using the plot function.

plot(djia.tsa)

# Press the "esc" key to "escape" the menu of plot options.

# ---------------------------------------------------------------------------------
# Gross National Product growth rate
# ---------------------------------------------------------------------------------

# In an previous learning unit, we used ARIMA models to explore the time series of Gross National Product (GNP) values from 1947 to 2002. Here, we work with a model for this time series that specifies ARCH errors.

# The following code loads the data from an external file using the "read.table" function.

setwd(DataDirectory)
gnp96.raw <- read.table("gnp96.dat", header=FALSE, sep="")
year <- gnp96.raw[[1]]
gnp.ts <- gnp96.raw[[2]]

# The data are transformed into a growth-rate time series, i.e., the first-difference of the log-transformed GNP time series.

gnp.ts <- ts(data=gnp96.raw[[2]], frequency=4, start=c(1947, 1))
dloggnp.ts <- ts(data=diff(log(gnp96.raw[[2]])), frequency=4, start=c(1947, 2))

# Plots of the GNP time series and GNP-returns time series are generated as follows

par(mfrow = c(2, 1))
par(mar=c(2.00, 2.00, 1.00, 1.00)) #bottom, left, top, and right
ts.plot(gnp.ts, xlab="year", ylab="value", main="gross national product")
ts.plot(dloggnp.ts, xlab="year", ylab="growth rate", main="growth rate gross national product")
par(mfrow = c(1, 1))

# The following call to the "garchFit" specifies an AR(1) model for the returns with a ARCH(1) model for the errors. 

dloggnp.tsa <- garchFit(~arma(1,0)+garch(1,0), data=dloggnp.ts)

# The analysis summary indicates the parameter estimates listed below:

summary(dloggnp.tsa)

# Parameter estimates:
# mu:      0.00527795
# ar1:     0.36656256
# omega:   0.00007331 (= alpha0)
# alpha1:  0.19447134
